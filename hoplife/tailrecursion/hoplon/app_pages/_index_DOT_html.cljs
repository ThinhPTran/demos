(ns tailrecursion.hoplon.app-pages._index_DOT_html (:require [tailrecursion.hoplon.reload :refer [reload-all]] [tailrecursion.javelin :refer [alts! cell-map propagate! next-rank deref* lift cell input? cell-doseq* bf-seq destroy-cell! last-rank set-cell! set-formula! cell?]] [tailrecursion.hoplon :refer [script do! track article noscript command h4 h3 mark basefont h5 span input h2 th label h6 pre nav vector?* address sup h1 table font option datalist u safe-nth on! footer select q samp source summary li p td noframes node? iframe rel tr s *initfns* add-attributes! colgroup relx html dfn optgroup tbody text-val! ul hgroup sub strong data progress loop-tpl* acronym append-child replace-children! img details fieldset html-head em html-time rt when-dom video keygen div val-id dt ol link init form is-ie8 check-val! menu timeout del a parse-args area legend hr dir header param meter tfoot blockquote eventsource b dl figcaption caption route-cell style rel-event abbr ruby applet html-meta bdi embed rp figure on-append! canvas section object strike title button output audio initialized? add-children! dd bdo cite code kbd big seq?* frame rely col tt i ins thead unsplice isindex frameset center spliced base $text by-id $comment br textarea wbr html-map small add-initfn! html-body aside html-var]]) (:require-macros [tailrecursion.javelin :refer [cell-doseq cell= defc defc= mx with-let prop-cell mx2 cell-let set-cell!= macroexpand-all]] [tailrecursion.hoplon :refer [with-init! body text defelem loop-tpl head with-timeout with-interval def-values flatten-expr]]))

(clojure.core/defn ^:export hoploninit [] (reload-all) (def default #{[2 1] [12 11] [2 2] [11 11] [0 1] [1 2] [13 11] [2 0]}) (def +size+ 16) (def +interval+ 100) (defc running? true) (defc alive default) (defn neighbours [[x y]] (for [dx [-1 0 1] dy (if (zero? dx) [-1 1] [-1 0 1])] [(mod (+ dx x) +size+) (mod (+ dy y) +size+)])) (defn step [cells] (set (for [[loc n] (frequencies (mapcat neighbours cells)) :when (or (= n 3) (and (= n 2) (cells loc)))] loc))) (defn click [cells xy] ((if (contains? cells xy) disj conj) cells xy)) (with-init! (with-interval +interval+ (when (clojure.core/deref running?) (swap! alive step)))) (html (head (title "Hoplife") (style :type "text/css" "table,th,td { margin:0; padding:0; border-spacing:0; }\ntable       { border:1px solid black; }\ntd          { width:16px; height:16px; cursor:pointer; }\ntd.alive    { background-color: black; }")) (body (button :click (fn* [] (swap! running? not)) :text (cell= (if running? "Stop" "Start"))) (button :click (fn* [] (swap! alive into default)) "Reset") (table (for [x (range +size+)] (tr (for [y (range +size+)] (td :click (fn* [] (swap! alive click [x y])) :class (cell= {"alive" (contains? alive [x y])})))))) (p (a :href "https://github.com/tailrecursion/hoplon-demos/tree/master/hoplife" "Source Code")))) (tailrecursion.hoplon/init))
