(ns tailrecursion.hoplon.app-pages._index_DOT_html (:require [tailrecursion.hoplon.reload :refer [reload-all]] [tailrecursion.javelin :refer [alts! cell-map propagate! next-rank deref* lift cell input? cell-doseq* bf-seq destroy-cell! last-rank set-cell! set-formula! cell?]] [tailrecursion.hoplon :refer [script do! track article noscript command h4 h3 mark basefont h5 span input h2 th label h6 pre nav vector?* address sup h1 table font option datalist u safe-nth on! footer select q samp source summary li p td noframes node? iframe rel tr s *initfns* add-attributes! colgroup relx html dfn optgroup tbody text-val! ul hgroup sub strong data progress loop-tpl* acronym append-child replace-children! img details fieldset html-head em html-time rt when-dom video keygen div val-id dt ol link init form is-ie8 check-val! menu timeout del a parse-args area legend hr dir header param meter tfoot blockquote eventsource b dl figcaption caption route-cell style rel-event abbr ruby applet html-meta bdi embed rp figure on-append! canvas section object strike title button output audio initialized? add-children! dd bdo cite code kbd big seq?* frame rely col tt i ins thead unsplice isindex frameset center spliced base $text by-id $comment br textarea wbr html-map small add-initfn! html-body aside html-var]]) (:require-macros [tailrecursion.javelin :refer [cell-doseq cell= defc defc= mx with-let prop-cell mx2 cell-let set-cell!= macroexpand-all]] [tailrecursion.hoplon :refer [with-init! body text defelem loop-tpl head with-timeout with-interval def-values flatten-expr]]))

(clojure.core/defn ^:export hoploninit [] (reload-all 1000) (defc text-input "") (defc range-input 20) (defc select-input "green") (defc multi-select #{"green"}) (defc check-box false) (defc radio-input "b") (html (head (title "Hoplon â€¢ Inputs")) (body (h1 "Inputs and state in Hoplon") (p "Each input example has a corresponding Javelin cell.\n      When you change the input its cell is updated.") (h2 "A simple text input") (p "This shows that you can have more than one field pointing to the same\n      cell. Edit one input and see everything change in sync.") (input :type "text" :placeholder "Type something here" :value text-input :keyup (fn* [p1__5371#] (reset! text-input (.. p1__5371# -target -value)))) (input :type "text" :placeholder "Type something here" :value text-input :keyup (fn* [p1__5372#] (reset! text-input (.. p1__5372# -target -value)))) (p (text "Value of text input: ~{text-input}")) (h2 "A range input") (p "Every example gets the value from a cell and updates it when it changes.") (input :style "width:400px" :type "range" :min 0 :max 100 :step 1 :value range-input :change (fn* [p1__5373#] (reset! range-input (.. p1__5373# -target -value)))) (p (text "Value of range input: ~{range-input}")) (h2 "A select input") (select :change (fn* [p1__5374#] (reset! select-input (.. p1__5374# -target -value))) :value select-input (option :value "blue" "blue") (option :value "green" "green") (option :value "gold" "gold") (option :value "indigo" "indigo")) (p (text "Value of select input: ~{select-input}")) (h2 "Multiple select input") (select :change (fn* [p1__5375#] (let [options (.. p1__5375# -target -selectedOptions) l (.-length options)] (reset! multi-select (set (for [i (range l)] (.-value (.item options i))))))) :multiple "true" (option :selected (cell= (multi-select "blue")) :value "blue" "blue") (option :selected (cell= (multi-select "green")) :value "green" "green") (option :selected (cell= (multi-select "gold")) :value "gold" "gold") (option :selected (cell= (multi-select "indigo")) :value "indigo" "indigo")) (p (text "Value of multiple select input: ~{multi-select}")) (h2 "A checkbox") (label (input :type "checkbox" :click (fn* [] (do (swap! check-box not) true)) :value check-box) "Checkbox") (p (text "Value of checkbox: ~{check-box}")) (h2 "A radio button") (label (input :type "radio" :click (fn* [p1__5376#] (reset! radio-input (.. p1__5376# -target -value))) :checked (cell= (= "a" radio-input)) :name "radio-group" :value "a") "a") (label (input :type "radio" :click (fn* [p1__5377#] (reset! radio-input (.. p1__5377# -target -value))) :checked (cell= (= "b" radio-input)) :name "radio-group" :value "b") "b") (p (text "Selected radio: ~{radio-input}")))) (tailrecursion.hoplon/init))
