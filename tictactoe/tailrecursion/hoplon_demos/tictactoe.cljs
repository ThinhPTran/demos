(ns tailrecursion.hoplon-demos.tictactoe (:require [tailrecursion.javelin :refer [alts! cell-map propagate! next-rank deref* lift cell input? cell-doseq* bf-seq destroy-cell! last-rank set-cell! set-formula! cell?]] [tailrecursion.hoplon :refer [script do! track article noscript command h4 h3 mark basefont h5 span input h2 th label h6 pre nav vector?* address sup h1 table font option datalist u safe-nth on! footer select q samp source summary li p td noframes node? iframe rel tr s *initfns* add-attributes! colgroup relx html dfn optgroup tbody text-val! ul hgroup sub strong data progress loop-tpl* acronym append-child replace-children! img details fieldset html-head em html-time rt when-dom video keygen div val-id dt ol link init form is-ie8 check-val! menu timeout del a parse-args area legend hr dir header param meter tfoot blockquote eventsource b dl figcaption caption route-cell style rel-event abbr ruby applet html-meta bdi embed rp figure on-append! canvas section object strike title button output audio initialized? add-children! dd bdo cite code kbd big seq?* frame rely col tt i ins thead unsplice isindex frameset center spliced base $text by-id $comment br textarea wbr html-map small add-initfn! html-body aside html-var]]) (:require-macros [tailrecursion.javelin :refer [cell-doseq cell= defc defc= mx with-let prop-cell mx2 cell-let set-cell!= macroexpand-all]] [tailrecursion.hoplon :refer [with-init! body text defelem loop-tpl head with-timeout with-interval def-values flatten-expr]]))

(def transpose (partial apply map vector))

(def diagonal (partial map (comp first drop) (range)))

(def indexed (partial map-indexed vector))

(def new-game (fn* [p1__6917#] (vec (repeat p1__6917# nil))))

(defelem scoreboard [{:keys [history]} _] (let [sorted (cell= (indexed (->> history (sort-by second) reverse)))] (table :class "score" (tr (th "rank") (th "player") (th "score")) (loop-tpl :bindings [[rank [player score]] sorted] (tr (td :align "center" (text "~(inc rank)")) (td :align "center" (text "~{player}")) (td :align "center" (text "~{score}")))))))

(defelem game [{:keys [size history], :or {size 3, history (cell [])}, :as attr} _] (let [rowsize (js/parseInt size) sizen (* rowsize rowsize) game (cell (new-game sizen)) rows (cell= (partition rowsize game)) columns (cell= (transpose rows)) diagonals (cell= [(diagonal rows) (diagonal (map reverse rows))]) runs (cell= (concat rows columns diagonals)) winner (cell= (->> runs (map set) (remove (fn* [p1__6918#] (contains? p1__6918# nil))) (filter (fn* [p1__6919#] (= 1 (count p1__6919#)))) ffirst)) moves (cell= (->> (indexed game) (filter (comp nil? second)) (map first))) no-moves? (cell= (not (seq moves))) over (cell= (cond winner (str winner " won!") no-moves? "Cat's game.")) ai! (fn [] (when-not (clojure.core/deref over) (swap! game assoc (rand-nth (clojure.core/deref moves)) "O"))) play! (fn [i j] (let [idx (+ (* i rowsize) j)] (when (and (not (clojure.core/deref over)) (nil? (get (clojure.core/deref game) idx))) (swap! game assoc idx "X"))))] (reset! history {"X" 0, "O" 0, "cat" 0}) (cell= (when (or winner no-moves?) (swap! (clojure.core/unquote (cell history)) update-in [(or winner "cat")] inc))) (div (dissoc attr :size :history) (table :class "tictac" (loop-tpl :bindings [[i row] (cell= (indexed rows))] (tr (loop-tpl :bindings [[j x] (cell= (indexed row))] (td :on-click (fn* [] (and (play! (clojure.core/deref i) (clojure.core/deref j)) (ai!))) (text "~{x}")))))) (div :do-toggle over (p (text "~{over}")) (button :on-click (fn* [] (reset! game (new-game sizen))) "Play Again")))))
