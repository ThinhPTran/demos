(ns tailrecursion.hoplon.app-pages._basic_DOT_html (:require [tailrecursion.javelin :refer [alts! cell-map propagate! next-rank deref* lift cell input? cell-doseq* bf-seq destroy-cell! last-rank set-cell! set-formula! cell?]] [tailrecursion.hoplon :refer [script do! track article noscript command h4 h3 mark basefont h5 span input h2 th label h6 pre nav vector?* address sup h1 table font option datalist u safe-nth on! footer select q samp source summary li p td noframes node? iframe rel tr s *initfns* add-attributes! colgroup relx html dfn optgroup tbody text-val! ul hgroup sub strong data progress loop-tpl* acronym append-child replace-children! img details fieldset html-head em html-time rt when-dom video keygen div val-id dt ol link init form is-ie8 check-val! menu timeout del a parse-args area legend hr dir header param meter tfoot blockquote eventsource b dl figcaption caption route-cell style rel-event abbr ruby applet html-meta bdi embed rp figure on-append! canvas section object strike title button output audio initialized? add-children! dd bdo cite code kbd big seq?* frame rely col tt i ins thead unsplice isindex frameset center spliced base $text by-id $comment br textarea wbr html-map small add-initfn! html-body aside html-var]]) (:require-macros [tailrecursion.javelin :refer [cell-doseq cell= defc defc= mx with-let prop-cell mx2 cell-let set-cell!= macroexpand-all]] [tailrecursion.hoplon :refer [with-init! body text defelem loop-tpl head with-timeout with-interval def-values flatten-expr]]))

(clojure.core/defn ^:export hoploninit [] (def transpose (partial apply map vector)) (def diagonal (partial map (comp first drop) (range))) (def indexed (partial map-indexed vector)) (def new-game (vec (repeat 9 nil))) (defc game new-game) (defc undos ()) (defc= rows (partition 3 game)) (defc= columns (transpose rows)) (defc= diagonals [(diagonal rows) (diagonal (map reverse rows))]) (defc= runs (concat rows columns diagonals)) (defc= winner (->> runs (map set) (remove (fn* [p1__6555#] (contains? p1__6555# nil))) (filter (fn* [p1__6556#] (= 1 (count p1__6556#)))) ffirst)) (defc= moves (->> (indexed game) (filter (comp nil? second)) (map first))) (defc= no-moves? (not (seq moves))) (defc= over (cond winner (str winner " won!") no-moves? "Cat's game.")) (defn undo! [] (when (seq (clojure.core/deref undos)) (reset! game (peek (clojure.core/deref undos))) (swap! undos pop))) (defn ai! [] (when-not (clojure.core/deref over) (swap! game assoc (rand-nth (clojure.core/deref moves)) "O"))) (defn play! [i j] (let [idx (+ (* i 3) j)] (when (and (not (clojure.core/deref over)) (nil? (get (clojure.core/deref game) idx))) (swap! undos conj (clojure.core/deref game)) (swap! game assoc idx "X")))) (defn reset-game! [] (reset! game new-game) (reset! undos ())) (html (head (title "Hoplon â€¢ Tic Tac Toe") (link :rel "stylesheet" :href "screen.css")) (body (table :class "tictac" (loop-tpl :bindings [[i row] (cell= (indexed rows))] (tr (loop-tpl :bindings [[j x] (cell= (indexed row))] (td :on-click (fn* [] (and (play! (clojure.core/deref i) (clojure.core/deref j)) (ai!))) (text "~{x}")))))) (div :do-toggle (cell= (and (not over) (seq undos))) (button :on-click undo! "Undo")) (div :do-toggle over (p (text "~{over}")) (button :on-click reset-game! "Play Again")) (a :href "https://github.com/tailrecursion/hoplon-demos/blob/master/tictactoe/src/basic.cljs.hl" "Source Code"))) (tailrecursion.hoplon/init))
