(ns tailrecursion.hoplon.app-pages._index_DOT_html (:require [clojure.string :as str] [tailrecursion.javelin :refer [alts! cell-map propagate! next-rank deref* lift cell input? cell-doseq* bf-seq destroy-cell! last-rank set-cell! set-formula! cell?]] [tailrecursion.hoplon :refer [script do! track article noscript command h4 h3 mark basefont h5 span input h2 th label h6 pre nav vector?* address sup h1 table font option datalist u safe-nth on! footer select q samp source summary li p td noframes node? iframe rel tr s *initfns* add-attributes! colgroup relx html dfn optgroup tbody text-val! ul hgroup sub strong data progress loop-tpl* acronym append-child replace-children! img details fieldset html-head em html-time rt when-dom video keygen div val-id dt ol link init form is-ie8 check-val! menu timeout del a parse-args area legend hr dir header param meter tfoot blockquote eventsource b dl figcaption caption route-cell style rel-event abbr ruby applet html-meta bdi embed rp figure on-append! canvas section object strike title button output audio initialized? add-children! dd bdo cite code kbd big seq?* frame rely col tt i ins thead unsplice isindex frameset center spliced base $text by-id $comment br textarea wbr html-map small add-initfn! html-body aside html-var]]) (:require-macros [tailrecursion.javelin :refer [cell-doseq cell= defc defc= mx with-let prop-cell mx2 cell-let set-cell!= macroexpand-all]] [tailrecursion.hoplon :refer [with-init! body text defelem loop-tpl head with-timeout with-interval def-values flatten-expr]]))

(clojure.core/defn ^:export hoploninit [] (defn generate-numbers "This generates a data vector with ten maps of sequential numbers.\n  Example: [{:number \"0\"} {:number \"1\"} ... {:number \"9\"}]" [n] (vec (map (fn [x] {:number (str x)}) (range (* (dec n) 10) (+ (* (dec n) 10) 10))))) (defn generate-data [n] "This generates a page map with this format\n  {\"1\" {:page 1, :data [...]}}" {(str n) {:page n, :data (generate-numbers n)}}) (def fake-api "This is a vector of pages from 1 to 99" (into {} (map generate-data (range 1 100)))) (defc state "The current state, a vector of loaded pages." []) (defc error "It will be a error message when a page is not found." nil) (defc loading "When it isn't empty, something is loading." []) (defc= loading? "True when there is something loading" (seq loading)) (defc= sorted-state "A vector of pages sorted by page" (vec (sort-by :page state))) (defc pages-loaded "Page numbers of loaded pages." []) (defc= prev-page "Previous page that should be loaded (when scrolling up)." (dec (apply min pages-loaded))) (defc= next-page "Next page number that should be loaded." (inc (apply max pages-loaded))) (defc last-scroll "Last scroll position" 0) (defc hash-scroll "When false disable the handler to scroll on hashchange." true) (defc timeout-id "Last setTimeout id so we can cancel it if needed." 0) (defn get-page "Get a page from the fake api and run a callback on the result." [p callback] (callback (fake-api p))) (defn fetch-page! "Put the page p on the state and on the pages-loaded." [p] (when-not (clojure.core/deref loading?) (reset! error nil) (swap! loading conj :loading) (let [q (str p)] (get-page q (fn* [p1__5373#] (do (swap! loading pop) (when p1__5373# (swap! state conj p1__5373#) (swap! pages-loaded conj p)) (when-not p1__5373# (reset! error "Sem mais páginas")))))))) (defn fetch-next-page! "Put the next page on the state and pages-loaded." [] (fetch-page! (clojure.core/deref next-page))) (defn fetch-prev-page! "Put the previous page on the state and pages-loaded and fix the scroll\n  position." [] (let [p (clojure.core/deref prev-page)] (fetch-page! p) (.scrollTop (js/jQuery js/window) (+ (.scrollTop (js/jQuery js/window)) (.height (js/jQuery (str "#page-" p))))))) (defn mostly-visible "Returns true if the element is the most visible on screen." [el] (let [w (js/jQuery js/window) vertical-scroll (.scrollTop w) window-height (.height w) el-top (.-top (.offset (js/jQuery el))) el-height (.height (js/jQuery el)) el-bottom (+ el-top el-height)] (and (> (- el-bottom (* el-height 0.25)) vertical-scroll) (< el-top (+ vertical-scroll (* 0.5 window-height)))))) (with-init! (if (= (.-length (.-hash (.-location js/window))) 0) (fetch-page! 1) (fetch-page! (js/parseInt (last (str/split (.-hash (.-location js/window)) #"/"))))) (on! js/window :scroll (fn* [] (let [w (js/jQuery js/window) vertical-scroll (.scrollTop w) window-height (.height w) document-height (.height (js/jQuery js/document)) at-end? (>= vertical-scroll (* 0.9 (- document-height window-height))) header-height (.height (js/jQuery "#header")) at-begin? (= vertical-scroll 0)] (when (> (.abs js/Math (- vertical-scroll (clojure.core/deref last-scroll))) (* 0.1 window-height)) (reset! last-scroll vertical-scroll) (.each (js/jQuery ".item-page") (fn [i v] (if (mostly-visible v) (do (js/clearTimeout (clojure.core/deref timeout-id)) (reset! hash-scroll false) (set! (.-hash (.-location js/window)) (.attr (js/jQuery v) "data-url")) (reset! timeout-id (js/setTimeout (fn [] (reset! hash-scroll true)) 500))))))) (if at-end? (fetch-next-page!) (when at-begin? (fetch-prev-page!)))))) (on! js/window :hashchange (fn* [] (when (clojure.core/deref hash-scroll) (let [p (last (str/split (.-hash (.-location js/window)) #"/")) el (js/jQuery (str "#page-" p))] (if (> (.-length el) 0) (let [position (.position el) tp (.-top position) b (js/jQuery "html,body")] (.animate b (clj->js {:scrollTop tp}))) (do (reset! last-scroll 0) (.reload (.-location js/window) true)))))))) (html :lang "en" (head (meta :charset "utf-8") (title "Hoplon • Infinite Scroll Paginated Demo")) (body (div :id "header" (h1 "Infinite Scrolling") (p "Scroll down to see more pages...")) (div :id "wrapper" (div :id "loading" :toggle loading? "LOADING IMAGES...") (div :id "error" :toggle error "No more pages: " (a :href "javascript:void(0)" :click fetch-next-page! "try again")) (div (loop-tpl :bindings [{p :page, d :data} sorted-state] (div :id (cell= (str "page-" p)) :class "item-page" :data-url (cell= (str "#/page/" p)) (h1 :id (cell= (str "page-" p)) (text "Page: ~{p}")) (loop-tpl :bindings [{it :number} d] (div :css {:height 100} (h2 (text "Number: ~{it}")))))))))) (tailrecursion.hoplon/init))
